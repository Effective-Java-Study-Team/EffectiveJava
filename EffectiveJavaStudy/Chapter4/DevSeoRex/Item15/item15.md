### 아이템 15 - 클래스와 멤버의 접근 권한을 최소화하라

- **정보 은닉의 중요성(캡슐화)**

잘 설계된 컴포넌트와 그렇지 못한 컴포넌트의 가장 큰 차이는 내부 데이터와 내부 구현 정보를 외부 컴포넌트로

부터 얼마나 잘 숨겼느냐의 여부이다.

잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리한다.

오직 API를 통해서만 소통할 수 있는 것이다. 컴포넌트간의 상호 협력에서 **서로 메시지만 전달할 뿐,**

내부에 어떤 값이 있는지 어떻게 동작하는지는 알 필요가 없다는 것에 기인한 것이다.

**정보은닉을 잘하면 어떤 장점이 있을까?**

- **시스템 개발 속도 증가**
    - 여러 컴포넌트를 병렬로 개발할 수 있다.
    - 정보은닉이 제대로 되지 않으면, 컴포넌트간 의존성과 결합도가 증가하고 이로인해 하나의 컴포넌트를 변경하면 다른 컴포넌트도 변경해야 할 가능성이 높기 때문이다.
- **시스템 관리 비용 절감**
    - 각 컴포넌트를 더 빨리 파악하여 디버깅 할 수 있다.
    - 사용하고 있는 컴포넌트를 다른 컴포넌트로 교체하는 부담도 적어진다.
    - 정보가 은닉되어 있으면 로우 레벨의 구현 디테일이 감춰지기 때문에 내부 동작을 이해하고 추론하는데 어려움이 줄어들게 된다.
- **정보 은닉 자체가 성능을 올려주진 않지만, 성능 최적화에 도움을 준다.**
    - 다른 컴포넌트에 영향을 주지 않고 원하는 컴포넌트만 최적화 할 수 있기 때문이다.
    - 최적화한 컴포넌트와 상호 작용하는 컴포넌트들의 성능도 함께 증가한다.
- **소프트웨어 재사용성을 높여준다.**
    - 외부에 거의 의존하지 않고 독자적으로 동작이 가능한 컴포넌트라면 낯선 환경에서도 유용하게 쓰일 가능성이 크다.
- **큰 시스템을 제작하는 난이도를 낮춰준다.**
    - 시스템 전체가 아직 완성되지 않아도 개별 컴포넌트 별로 동작을 검증할 수 있다.
    - 전체 시스템이 완성되기 전에 개별 컴포넌트를 검증하고, 컴포넌트 간의 상호 동작을 테스트하면 전체 시스템이 완성되지 않아도 선제적인 검증이 가능하다.

- **Java의 접근 제어 매커니즘**

자바는 접근 제한자(access-modifier)를 통해 접근 허용 범위를 명시하고 있다.

각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자로 정해지게 된다. 

이 접근 제한자를 잘 쓰는 것이 정보 은닉의 핵심이다.

![image](https://github.com/Effective-Java-Study-Team/EffectiveJava/assets/91787050/04ac7343-3c6c-4cbe-ba21-7bf4833a4fc7)

접근 제어자를 잘 사용할 수 있는 방법은 간단한다.

필드나 메서드에 final을 붙여야 할 지 정하는 간단한 기준과 비슷하다고 볼 수 있다.

먼저 **final 키워드**를 붙여 놓은후에, 필드라면 변경 할 필요성이 생겼거나 메서드라면 재정의 할 필요성이 생긴

다면 그때 **final 키워드**를 제거하고 변경과 재정의를 열어주면 된다.

처음부터 문을 활짝 열고 모든 접근을 허용하지 말라는 이야기다.

모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다는 것이다. **개발한 애플리케이션이 제대로 동작하는 한 가장 낮은 접근 수준을 부여해야 한다는 뜻이다.**

- **접근 제한자를 사용하는 기술**

먼저 가장 바깥이라는 의미의 **톱레벨 클래스와 인터페이스**에 부여할 수 있는 접근 수준은 **package-private과 public 두 가지 뿐이다.**

톱레벨 클래스나 인터페이스는 **public 선언시 공개 API**가 되고, **package-private으로 선언하면 해당 패키지 안에서만 이용할 수 있다.**

지금 정의한 클래스와 인터페이스를 봤을때 패키지 외부에서 쓸 이유가 없다면 package-private로 선언하자.

**public API는 하위 호환을 위해 영원히 관리**해줘야 한다. 심지어 많은 문제가 있더라도 말이다.

**package-private**는 내부 구현에 해당하므로 이 부분에 대해서는 언제든지 클라이언트에게 피해를 주지 않고,

**수정 & 교체 & 제거** 할 수 있다.

한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 이를 사용하는 클래스 안에 **private**

**static으로 중첩시키는 것이 좋다.**

```java
class Magician extends Adventurer {

    private Weapon weapon;

    public void attack() {
        weapon.attack();
    }

    public void magicClaw() {
        SkillOfMagician.magicClaw();
    }

    public void setWeapon(Weapon weapon) {
        this.weapon = weapon;
    }

    // 한 클래스에서만 사용하는 클래스라면 private static inner class로 사용하자
    private static class SkillOfMagician {

        private static void magicClaw() {
            System.out.println("magicClaw!!!");
        }
    }
}
```

간단한 공격과 스킬 하나를 가진 마법사 클래스이다.

이 마법사 클래스는 마법사만 사용할 수 있는 스킬을 모아 둔 SkillOfMagician 클래스를 내부 정적 클래스로

가지고 있다.

마법사 클래스가 아닌 전사 클래스는 SkillOfMagician 클래스의 스킬을 사용할 수도 없고 사용해서도 안된다.

정보 은닉의 **핵심은 접근이 필요하지 않은 범위(전사가 마법사 스킬 클래스에 접근할 수 있는 것)까지**

**접근을 허용하지 않고** 애플리케이션이 정상 동작하는 범위까지 **최대한 접근 범위는 좁게** 가져가자는 것이다.

클래스의 공개 API를 설계한 뒤에는 모든 멤버는 private으로 변경해야 한다.

같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한해서만 package-private로 풀어주자.

private과 package-private 멤버는 모두 해당 클래스의 구현에 해당하기 때문에, 보통은 공개 API에 영향을 주지 않는다.

Serializable을 구현한 클래스의 경우 **직렬화 과정을 거치며 외부로 필드들도 공개되어 공개 API가 될 수 있다.**

public 클래스에서 멤버를 protected로 변경하는 순간 그 멤버에 접근할 수 있는 대상 범위는 엄청 넓어진다.

**public 클래스의 protected 멤버는 공개 API 이므로 영원히 지원되야 한다.**

내부 동작 방식을 API 문서에 적어 사용자에게 공개해야 할 수도 있다.

왜냐하면 protected는 상속을 통한 재정의가 가능하기 때문에, **API 디자인에 맞게 사용자가 사용할 수 있도록**

**가이드라인을 제공해야 큰 문제없이 확장이 가능할 것이기 때문이다.**

그러므로 protected 멤버는 그 수가 적을수록 좋다.

- **멤버 접근성을 좁히기 어려운 이유**

상위 클래스의 메서드를 재정의할 때는 **그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다.**

이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙을 지키기

위해 존재한다.

```java
class Parent {

    public void doSomething() {
    	System.out.println("doSomething by Parent.. !");
    }
}

class Child extends Parent {

      @Override
      private void doSomething() {
      	System.out.println("doSomething by Child.. !");
      }
}

public static void main(String[] args) {
      Parent parent = new Parent();
      parent.doSomething(); // "doSomething by Parent.. !" 출력
          
      parent = new Child();
      parent.doSomething(); // 호출 불가 -> private(LSP 위반)
}
```

물론 이 위의 코드는 컴파일 조차 되지 않는다.

상위 인스턴스를 하위 인스턴스로 교체할 수 없는 LSP 위반 상황을 코드로 보여주기 위해 작성한 코드다.

클래스가 인터페이스를 구현하는 건 이 규칙의 특별한 예로 볼 수 있다.

인터페이스는 public 멤버만 가질 수 있고, private으로 선언해야 하는 메서드는 직접 인터페이스 내에서 구현해야 한다.

클래스가 인터페이스를 구현하면 모든 메서드는 public으로 구현해야 한다.

작성한 코드의 테스트를 위해 접근 범위를 넓히는 것은 상관없다.

물론 적당한 수준까지만 넓혀야 한다. 

public 클래스의 private 멤버를 package-private까지 풀어주는 것은 가능하지만 **그 이상 넓히게 된다면 public API가 되버린다.**

다행히도 테스트 코드를 테스트 대상과 같은 패키지에 두면 이런 문제가 발생하지 않는다.

- **public 클래스의 인스턴스 필드는 되도록이면 public이 아니어야 한다.**

필드가 가변 객체를 참조하거나 final이 아닌 인스턴스 필드를 public으로 선언하면 담을 수 있는 값을 제한할 힘을 잃어 문제가 생길 수 있다.

필드가 수정될 때(락 획득) 다른 작업을 할 수 없게 되어서 멀티 스레드 환경에서 안전하지 못하다.

물론 심지어 필드가 final 이면서 불변 객체를 참조하더라도 문제가 남는다.

```java
public class FoodWord {

      /*
      *	외부에서 인스턴스 필드에 의존적이라면 이 필드를 private 으로 접근 범위를 
      * 좁힌 리팩토링 방식은 적용 불가하다.
      */ 
      public final String FOOD_PREFIX = "FOOD_";
}

public class ChineseFood {

      public void getFood() {
      	// 외부 클래스에서 이미 인스턴스 필드에 의존하고 있다.
      	System.out.println(new FoodWord().FOOD_PREFIX + "Chinese가 나왔습니다.");
      }

}
```

final 키워드를 붙였기 때문에 수정은 불가능하지만 외부 클래스에서 이 인스턴스 필드에 의존하고 있다면 

내부 구현을 바꾸더라도 public 필드를 없애는 방식으로는 리팩터링 할 여지 조차 잃게 된다.

정적 필드에서도 동일한 문제를 일으킨다.

하지만 예외 케이스가 하나 있다. 해당 클래스가 표현하는 추상 개념을 완성하는데 꼭 필요한 구성요소로써의

**상수일 경우 public static final 필드로 공개해도 좋다.**

상수는 반드시 불변 객체나 기본 타입 값을 참조해야 한다.

가변 객체를 참조한다면 final이 아닌 필드에 적용되는 모든 불이익이 그대로 적용된다.

배열도 마찬가지다. 길이가 0이 아닌 배열은 모두 변경이 가능하다는 점에 주의하자.

**public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.**

클래스에서 멤버로 내부 배열을 꼭 가지고 있어야 한다면, 복사해서 반환하거나 불변 리스트를 추가하는 방법으로 

이 문제를 해결할 수 있다.

```java
// 불변 리스트 추가 방식
private static final Thing[] PRIVATE_VALUES = {};
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES);

// 방어적 복사 기법을 활용한 반환 방식
private static final Thing[] PRIVATE_VALUES = {};
public static final Thing[] values() {
		return PRIVATE_VALUES.clone();
}
```

용도에 따라서 배열의 내부를 단순 확인하고 값을 가져오기만 하는 경우라면 불변 리스트 추가 방식을,

**배열의 값을 편집해서 로직을 수행하는 경우**라면 방어적 복사 기법을 활용한 방식이 좋아보인다.

- **Java 9의 모듈 시스템**

Java 8까지 접근 제어자만으로는 완벽한 캡슐화를 이루지 못했다.

그래서 Java 9 부터 **모듈 시스템이 도입**되었다. 모듈 시스템은 직소(Jigsaw) 프로젝트 내부에서 개발된 기능으로

완성까지 십 년이 걸린 숙원 사업이였다.

### 관심사 분리

SoC(Separation of concerns)를 적용하면 여러개의 기능을 모듈이라는 각각의 부분, 서로 거의 겹치지 않는

코드 그룹으로 분리할 수 있게 된다.

클래스를 그룹화한 모듈을 이용해 애플리케이션의 클래스 간의 관계를 시각적으로 보여줄 수 있는 것이다.

자바 패키지도 클래스를 그룹으로 만든다고 볼 수도 있겠지만, 자바 9에서 나온 모듈의 기능은 약간 다르다.

Java 9에서 나온 모듈은 클래스가 어떤 다른 클래스를 볼 수 있는지를 컴파일 시간에 정교하게 제어할 수 있다.

자바 패키지는 모듈성을 지원하지 않는다.

### 정보 은닉

정보 은닉의 관점에서 봤을때도 자바 8은 아쉬운 점이 있다.

Java 8 까지는 클래스 내의 컴포넌트에 적절하게 private 제어자를 사용했는지를 기준으로 **컴파일러를 이용해 캡슐화를 확인할 수 있다.**

Java 9 이전까지는 클래스와 패키지가 의도된 대로 공개되었는지를 컴파일러를 통해 확인할 방법은 없었다.

즉 Java 9 부터 **클래스와 패키지가 의도된 대로 공개되었는지를 확인**할 수 있게 되어 더 좋은 소프트웨어 아키텍처를 가져갈 수 있게 된것이다.

### 모듈 시스템이 필요했던 이유

- **모듈화의 한계**

Java 9 이전까지는 클래스, 패키지, JAR 세가지 수준의 코드 그룹화를 제공했었다.

클래스와 관련해 접근 제한자와 캡슐화를 지원했지만 패키지와 JAR 수준에서는 캡슐화를 거의 지원하지 않았다.

- **제한된 가시성 제어**

한 패키지의 클래스와 인터페이스를 다른 패키지로 공개하려면 public으로 이들을 선언해줘야 한다.

결과적으로 이 클래스와 인터페이스는 모두에게 공개되어 public API가 되는 것이다.

보통 impl 키워드가 붙은 패키지에서 패키지 내부의 접근자가 public 이므로, 사용자가 이 내부 구현을 마음대로

사용할 수 있다는 문제가 있다.

내부적으로 사용할 목적으로 만든 구현을 다른 프로그래머가 임시적으로 사용하다 정착해버릴 수 있는 문제가

생기고, 라이브러리 코드를 바꾸기 어려워진다.

보안 측면에서도 코드를 임의로 조작하는 문제에 노출될 수 있다.

### 모듈 시스템의 기능과 동작

![image](https://github.com/Effective-Java-Study-Team/EffectiveJava/assets/91787050/f1ffefae-78c3-4886-bafe-9bffd1ec6a74)

### 모듈화 기능이 등장한 이유 정리

- **패키지의 캡슐화가 완벽하지 않다.**
    - 패키지는 공개 또는 비공개 둘 중 하나만 선택할 수 있어서 여러 패키지에서 공용으로 사용할 클래스를 외부에 공개하는 방법밖에 없다.
    - 외부에 공개한 클래스는 어디서든 자유롭게 사용할 수 있어서, 사용자가 내부 기능을 사용함으로 인하여 자유롭게 유지, 보수 할 수 없게 된다.
- **빌드 단계에서 프로그램 구동에 필요한 모든 클래스가 다 있는지 확인할 수 없다.**
    - 자바는 동적 로딩을 통해 필요한 클래스를 실행중에 로드한다.
    - 실행 직후에는 누락 사실을 바로 알 수 없다는 문제가 있다.
        - 누락을 방지하려면 수작업으로 일일히 확인하는 수밖에 없다.
- **런타임이 거대해져 배포가 어려워졌다.**
    - 초기의 자바 플랫폼은 라이브러리의 모든 클래스를 rt.jar 단 하나의 파일에 통합 배포해왔다.
    - 자바 버전이 올라가면서 rt.jar는 60M 이상의 덩치를 가지고 2만개 이상의 클래스를 포함하게 되어 초대형 런타임이 되었다.
 
### 총 정리

1. 프로그램 요소의 **접근성은 가능한 한 최소한**으로 하라.
2. 클래스, 인터페이스, 멤버가 의도치 않게 **API로 공개되는 일이 없도록 해야한다.**
3. public 클래스는 **public static final 상수 필드** 외에는 어떠한 public 필드도 가져서는 안된다.
  
